/**
 * Vulnerability Checker
 * Checks WordPress components against vulnerability databases
 * Phase 1: Core Scanning Engine
 */

export interface Vulnerability {
  id: string;
  cve_id?: string;
  title: string;
  description: string;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  cvss_score?: number;
  affected_versions: string;
  fixed_in?: string;
  references: string[];
  published_date: string;
  vuln_type?: string; // XSS, SQL Injection, etc.
}

export interface VulnerabilityCheckResult {
  core_vulnerabilities: Vulnerability[];
  plugin_vulnerabilities: Record<string, Vulnerability[]>; // slug => vulnerabilities
  theme_vulnerabilities: Record<string, Vulnerability[]>; // slug => vulnerabilities
  total_vulnerabilities: number;
  severity_breakdown: {
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  // Compatibility shape for legacy callers
  core: Vulnerability[];
  plugins: Record<string, Vulnerability[]>;
  themes: Record<string, Vulnerability[]>;
}

/**
 * Check WordPress site for vulnerabilities
 */
export async function checkVulnerabilities(
  coreVersionOrObject:
    | string
    | {
        core: { version: string } | { version: string; [k: string]: any };
        plugins: Array<{ slug: string; version: string }>;
        themes: Array<{ slug: string; version: string }>;
      },
  maybePlugins?: Array<{ slug: string; version: string }>,
  maybeThemes?: Array<{ slug: string; version: string }>
): Promise<VulnerabilityCheckResult> {
  try {
    // Normalize inputs to versions
    let coreVersion: string;
    let plugins: Array<{ slug: string; version: string }>;
    let themes: Array<{ slug: string; version: string }>;

    if (typeof coreVersionOrObject === 'string') {
      coreVersion = coreVersionOrObject;
      plugins = maybePlugins || [];
      themes = maybeThemes || [];
    } else {
      coreVersion = coreVersionOrObject.core?.version || 'unknown';
      plugins = coreVersionOrObject.plugins || [];
      themes = coreVersionOrObject.themes || [];
    }

    // Check vulnerabilities in parallel
    const [coreVulns, pluginVulns, themeVulns] = await Promise.allSettled([
      checkCoreVulnerabilities(coreVersion),
      checkPluginVulnerabilities(plugins),
      checkThemeVulnerabilities(themes),
    ]);
    
    const coreVulnerabilities = coreVulns.status === 'fulfilled' ? coreVulns.value : [];
    const pluginVulnerabilities = pluginVulns.status === 'fulfilled' ? pluginVulns.value : {};
    const themeVulnerabilities = themeVulns.status === 'fulfilled' ? themeVulns.value : {};
    
    // Calculate totals
    const totalVulnerabilities = 
      coreVulnerabilities.length +
      Object.values(pluginVulnerabilities).flat().length +
      Object.values(themeVulnerabilities).flat().length;
    
    // Calculate severity breakdown
    const allVulns = [
      ...coreVulnerabilities,
      ...Object.values(pluginVulnerabilities).flat(),
      ...Object.values(themeVulnerabilities).flat(),
    ];
    
    const severityBreakdown = {
      critical: allVulns.filter(v => v.severity === 'CRITICAL').length,
      high: allVulns.filter(v => v.severity === 'HIGH').length,
      medium: allVulns.filter(v => v.severity === 'MEDIUM').length,
      low: allVulns.filter(v => v.severity === 'LOW').length,
    };
    
    return {
      core_vulnerabilities: coreVulnerabilities,
      plugin_vulnerabilities: pluginVulnerabilities,
      theme_vulnerabilities: themeVulnerabilities,
      total_vulnerabilities: totalVulnerabilities,
      severity_breakdown: severityBreakdown,
      // Legacy shape
      core: coreVulnerabilities,
      plugins: pluginVulnerabilities,
      themes: themeVulnerabilities,
    };
    
  } catch (error) {
    console.error('Vulnerability check error:', error);
    return {
      core_vulnerabilities: [],
      plugin_vulnerabilities: {},
      theme_vulnerabilities: {},
      total_vulnerabilities: 0,
      severity_breakdown: { critical: 0, high: 0, medium: 0, low: 0 },
      core: [],
      plugins: {},
      themes: {},
    };
  }
}

/**
 * Check WordPress core vulnerabilities
 */
async function checkCoreVulnerabilities(version: string): Promise<Vulnerability[]> {
  if (version === 'unknown') {
    return [];
  }
  
  try {
    // Try WPVulnDB API first
    const wpvulndbResults = await checkWPVulnDB('wordpress', version);
    if (wpvulndbResults.length > 0) {
      return wpvulndbResults;
    }
    
    // Fallback to local known vulnerabilities database
    return checkLocalCoreVulnerabilities(version);
    
  } catch (error) {
    console.error('Core vulnerability check error:', error);
    return checkLocalCoreVulnerabilities(version);
  }
}

/**
 * Check plugin vulnerabilities
 */
async function checkPluginVulnerabilities(
  plugins: Array<{ slug: string; version: string }>
): Promise<Record<string, Vulnerability[]>> {
  const result: Record<string, Vulnerability[]> = {};
  
  // Check plugins in parallel (limit concurrency to avoid rate limits)
  const batchSize = 5;
  for (let i = 0; i < plugins.length; i += batchSize) {
    const batch = plugins.slice(i, i + batchSize);
    
    await Promise.allSettled(
      batch.map(async (plugin) => {
        if (plugin.version === 'unknown') {
          result[plugin.slug] = [];
          return;
        }
        
        try {
          // Try WPVulnDB API
          const vulns = await checkWPVulnDB(`plugins/${plugin.slug}`, plugin.version);
          result[plugin.slug] = vulns;
        } catch (error) {
          // Fallback to local database
          result[plugin.slug] = checkLocalPluginVulnerabilities(plugin.slug, plugin.version);
        }
      })
    );
    
    // Rate limiting delay between batches
    if (i + batchSize < plugins.length) {
      await new Promise(resolve => setTimeout(resolve, 500));
    }
  }
  
  return result;
}

/**
 * Check theme vulnerabilities
 */
async function checkThemeVulnerabilities(
  themes: Array<{ slug: string; version: string }>
): Promise<Record<string, Vulnerability[]>> {
  const result: Record<string, Vulnerability[]> = {};
  
  await Promise.allSettled(
    themes.map(async (theme) => {
      if (theme.version === 'unknown') {
        result[theme.slug] = [];
        return;
      }
      
      try {
        // Try WPVulnDB API
        const vulns = await checkWPVulnDB(`themes/${theme.slug}`, theme.version);
        result[theme.slug] = vulns;
      } catch (error) {
        // Fallback to local database
        result[theme.slug] = checkLocalThemeVulnerabilities(theme.slug, theme.version);
      }
    })
  );
  
  return result;
}

/**
 * Check WPVulnDB API for vulnerabilities
 * Free tier: 25 requests/day (implement caching in production)
 */
async function checkWPVulnDB(componentPath: string, version: string): Promise<Vulnerability[]> {
  // Check if API token is configured
  const apiToken = process.env.WPVULNDB_API_TOKEN;
  
  if (!apiToken) {
    // No API token configured, skip WPVulnDB
    return [];
  }
  
  try {
    const response = await fetch(
      `https://wpscan.com/api/v3/${componentPath}`,
      {
        headers: {
          'Authorization': `Token token=${apiToken}`,
        },
        signal: AbortSignal.timeout(8000),
      }
    );
    
    if (!response.ok) {
      if (response.status === 404) {
        // Component not found in database (not vulnerable or unknown)
        return [];
      }
      throw new Error(`WPVulnDB API error: ${response.status}`);
    }
    
    const data = await response.json();
    
    // Parse WPScan API response format
    const vulnerabilities: Vulnerability[] = [];
    
    // WPScan API returns data in format: { [component]: { vulnerabilities: [...] } }
    const componentKey = Object.keys(data)[0];
    if (data[componentKey]?.vulnerabilities) {
      for (const [vulnId, vulnData] of Object.entries(data[componentKey].vulnerabilities)) {
        const vuln = vulnData as any;
        
        // Check if current version is affected
        if (isVersionAffected(version, vuln.fixed_in)) {
          vulnerabilities.push({
            id: vulnId,
            cve_id: vuln.cve || undefined,
            title: vuln.title || 'Vulnerability detected',
            description: vuln.description || '',
            severity: mapSeverity(vuln.cvss?.score),
            cvss_score: vuln.cvss?.score,
            affected_versions: formatAffectedVersions(vuln.fixed_in),
            fixed_in: vuln.fixed_in,
            references: vuln.references?.url || [],
            published_date: vuln.published_date || new Date().toISOString(),
            vuln_type: vuln.vuln_type,
          });
        }
      }
    }
    
    return vulnerabilities;
    
  } catch (error) {
    console.error('WPVulnDB API error:', error);
    return [];
  }
}

/**
 * Local WordPress core vulnerability database (fallback)
 * Contains known critical vulnerabilities
 */
function checkLocalCoreVulnerabilities(version: string): Vulnerability[] {
  const knownVulnerabilities: Array<{
    affected: string; // version range
    fixed_in: string;
    vulnerability: Vulnerability;
  }> = [
    {
      affected: '<6.4.3',
      fixed_in: '6.4.3',
      vulnerability: {
        id: 'wp-core-6.4.3-xss',
        title: 'WordPress Core < 6.4.3 - Authenticated Stored Cross-Site Scripting',
        description: 'WordPress Core is vulnerable to Stored Cross-Site Scripting via user supplied attributes in the Shortcode block.',
        severity: 'MEDIUM',
        cvss_score: 6.4,
        affected_versions: '< 6.4.3',
        fixed_in: '6.4.3',
        references: ['https://wordpress.org/news/2024/01/wordpress-6-4-3/'],
        published_date: '2024-01-30',
        vuln_type: 'XSS',
      },
    },
    {
      affected: '<6.4.2',
      fixed_in: '6.4.2',
      vulnerability: {
        id: 'wp-core-6.4.2-rce',
        title: 'WordPress Core < 6.4.2 - Remote Code Execution via PHP Phar Deserialization',
        description: 'WordPress Core is vulnerable to Remote Code Execution via PHP Phar Deserialization.',
        severity: 'CRITICAL',
        cvss_score: 9.8,
        affected_versions: '< 6.4.2',
        fixed_in: '6.4.2',
        references: ['https://wordpress.org/news/2023/12/wordpress-6-4-2/'],
        published_date: '2023-12-06',
        vuln_type: 'RCE',
      },
    },
  ];
  
  const vulnerabilities: Vulnerability[] = [];
  
  for (const known of knownVulnerabilities) {
    if (isVersionVulnerable(version, known.affected)) {
      vulnerabilities.push(known.vulnerability);
    }
  }
  
  return vulnerabilities;
}

/**
 * Local plugin vulnerability database (fallback)
 * Contains some common vulnerable plugins
 */
function checkLocalPluginVulnerabilities(slug: string, version: string): Vulnerability[] {
  const knownVulnerabilities: Record<string, Array<{
    affected: string;
    vulnerability: Vulnerability;
  }>> = {
    'contact-form-7': [
      {
        affected: '<5.9',
        vulnerability: {
          id: 'cf7-5.9-xss',
          title: 'Contact Form 7 < 5.9 - Stored Cross-Site Scripting',
          description: 'The Contact Form 7 plugin is vulnerable to Stored Cross-Site Scripting.',
          severity: 'HIGH',
          cvss_score: 7.1,
          affected_versions: '< 5.9',
          fixed_in: '5.9',
          references: ['https://contactform7.com/'],
          published_date: '2024-01-15',
          vuln_type: 'XSS',
        },
      },
    ],
    'elementor': [
      {
        affected: '<3.18',
        vulnerability: {
          id: 'elementor-3.18-xss',
          title: 'Elementor < 3.18 - Authenticated Stored Cross-Site Scripting',
          description: 'The Elementor plugin is vulnerable to Stored Cross-Site Scripting.',
          severity: 'MEDIUM',
          cvss_score: 6.5,
          affected_versions: '< 3.18',
          fixed_in: '3.18',
          references: ['https://elementor.com/'],
          published_date: '2023-11-20',
          vuln_type: 'XSS',
        },
      },
    ],
    'woocommerce': [
      {
        affected: '<8.5',
        vulnerability: {
          id: 'woo-8.5-sqli',
          title: 'WooCommerce < 8.5 - SQL Injection',
          description: 'The WooCommerce plugin is vulnerable to SQL Injection.',
          severity: 'CRITICAL',
          cvss_score: 9.1,
          affected_versions: '< 8.5',
          fixed_in: '8.5',
          references: ['https://woocommerce.com/'],
          published_date: '2024-01-05',
          vuln_type: 'SQL Injection',
        },
      },
    ],
  };
  
  const vulns = knownVulnerabilities[slug] || [];
  const applicableVulns: Vulnerability[] = [];
  
  for (const known of vulns) {
    if (isVersionVulnerable(version, known.affected)) {
      applicableVulns.push(known.vulnerability);
    }
  }
  
  return applicableVulns;
}

/**
 * Local theme vulnerability database (fallback)
 */
function checkLocalThemeVulnerabilities(slug: string, version: string): Vulnerability[] {
  // For now, return empty array
  // Can be expanded with known theme vulnerabilities
  return [];
}

/**
 * Check if version is vulnerable based on affected range
 * Format: "<6.4.3" means vulnerable if version < 6.4.3
 */
function isVersionVulnerable(version: string, affectedRange: string): boolean {
  if (version === 'unknown') {
    return false;
  }
  
  // Parse affected range
  if (affectedRange.startsWith('<')) {
    const compareVersion = affectedRange.substring(1).trim();
    return compareVersions(version, compareVersion) < 0;
  }
  
  if (affectedRange.startsWith('<=')) {
    const compareVersion = affectedRange.substring(2).trim();
    return compareVersions(version, compareVersion) <= 0;
  }
  
  // Exact version match
  return version === affectedRange;
}

/**
 * Check if version is affected (fixed_in means vulnerable if version < fixed_in)
 */
function isVersionAffected(version: string, fixedIn: string | undefined): boolean {
  if (!fixedIn || version === 'unknown') {
    return false;
  }
  
  return compareVersions(version, fixedIn) < 0;
}

/**
 * Compare two version strings
 */
function compareVersions(v1: string, v2: string): number {
  const parts1 = v1.split('.').map(n => parseInt(n) || 0);
  const parts2 = v2.split('.').map(n => parseInt(n) || 0);
  
  for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
    const p1 = parts1[i] || 0;
    const p2 = parts2[i] || 0;
    
    if (p1 < p2) return -1;
    if (p1 > p2) return 1;
  }
  
  return 0;
}

/**
 * Map CVSS score to severity level
 */
function mapSeverity(cvssScore: number | undefined): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {
  if (!cvssScore) return 'MEDIUM';
  
  if (cvssScore >= 9.0) return 'CRITICAL';
  if (cvssScore >= 7.0) return 'HIGH';
  if (cvssScore >= 4.0) return 'MEDIUM';
  return 'LOW';
}

/**
 * Format affected versions string
 */
function formatAffectedVersions(fixedIn: string | undefined): string {
  if (!fixedIn) return 'All versions';
  return `< ${fixedIn}`;
}

/**
 * Calculate risk score based on vulnerabilities
 */
export function calculateRiskScore(vulnerabilities: VulnerabilityCheckResult): number {
  const { severity_breakdown, total_vulnerabilities } = vulnerabilities;
  
  if (total_vulnerabilities === 0) {
    return 100; // Perfect score, no vulnerabilities
  }
  
  // Weight vulnerabilities by severity
  const weightedScore = 
    (severity_breakdown.critical * 25) +
    (severity_breakdown.high * 15) +
    (severity_breakdown.medium * 8) +
    (severity_breakdown.low * 3);
  
  // Calculate score (100 - penalty)
  const score = Math.max(0, 100 - weightedScore);
  
  return Math.round(score);
}
